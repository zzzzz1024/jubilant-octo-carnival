{"version":3,"file":"index.js","mappings":"gQAEAA,EAAEC,gBCqHKA,eAAuCC,EAAcC,EAAwBC,GAClF,MAAMC,SAAyBC,aAAaJ,IAAOK,QAAQC,QAAU,QACjE,EAAQH,EAAiBF,EAAgB,cAGvCM,mBAAmBP,QAAYQ,MAAMN,GAASO,KAAKC,GAAYA,EAASC,SAC9EC,iBAAiBZ,EAAM,CAAEK,QAASJ,IAClCY,OAAOC,QACL,cAAcb,EAAec,WAAW,KAAOd,EAAiB,IAAIA,OACpED,GAEJ,CD/HQgB,CACJ,gBACMR,MAAM,2FACTC,KAAKC,GAAYA,EAASO,QAC1BR,KAAKQ,GAAQC,EAAEC,IAAIC,KAAKC,MAAMJ,GAAO,KAAM,UAC3CK,MAAM,IAAM,SACf","sources":["src://tavern_helper_template/示例/角色卡示例/脚本/自动更新角色卡/index.ts","src://tavern_helper_template/util/common.ts"],"sourcesContent":["import { checkAndUpdateCharacter } from '@util/common';\n\n$(async () => {\n  await checkAndUpdateCharacter(\n    '呕吐内心的少女',\n    await fetch('https://testingcf.jsdelivr.net/gh/StageDog/tavern_helper_template/dist/角色卡示例/index.yaml')\n      .then(response => response.text())\n      .then(text => _.get(YAML.parse(text), '版本', '0.0.0'))\n      .catch(() => '0.0.0'),\n    'https://testingcf.jsdelivr.net/gh/StageDog/tavern_helper_template/dist/角色卡示例/角色卡示例.png',\n  );\n});\n","import { compare } from 'compare-versions';\nimport JSON5 from 'json5';\nimport { jsonrepair } from 'jsonrepair';\nimport { toDotPath } from 'zod/v4/core';\n\nexport function assignInplace<T>(destination: T[], new_array: T[]): T[] {\n  destination.length = 0;\n  destination.push(...new_array);\n  return destination;\n}\n\nexport function chunkBy<T>(array: T[], predicate: (lhs: T, rhs: T) => boolean): T[][] {\n  if (array.length === 0) {\n    return [];\n  }\n\n  const chunks: T[][] = [[array[0]]];\n  for (const [lhs, rhs] of _.zip(_.dropRight(array), _.drop(array))) {\n    if (predicate(lhs!, rhs!)) {\n      chunks[chunks.length - 1].push(rhs!);\n    } else {\n      chunks.push([rhs!]);\n    }\n  }\n  return chunks;\n}\n\nexport function regexFromString(input: string, replace_macros?: boolean): RegExp | null {\n  if (!input) {\n    return null;\n  }\n  const makeRegex = (pattern: string, flags: string) => {\n    if (replace_macros) {\n      pattern = substitudeMacros(pattern);\n    }\n    return new RegExp(pattern, flags);\n  };\n  try {\n    const match = input.match(/\\/(.+)\\/([a-z]*)/i);\n    if (!match) {\n      return makeRegex(_.escapeRegExp(input), 'i');\n    }\n    if (match[2] && !/^(?!.*?(.).*?\\1)[gmixXsuUAJ]+$/.test(match[3])) {\n      return makeRegex(input, 'i');\n    }\n    let flags = match[2] ?? '';\n    _.pull(flags, 'g');\n    if (flags.indexOf('i') === -1) {\n      flags = flags + 'i';\n    }\n    return makeRegex(match[1], flags);\n  } catch {\n    return null;\n  }\n}\n\nexport function uuidv4(): string {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    const r = (Math.random() * 16) | 0;\n    const v = c === 'x' ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n}\n\nexport async function checkMinimumVersion(expected: string, title: string) {\n  if (compare(await getTavernHelperVersion(), expected, '<')) {\n    toastr.error(`'${title}' 需要酒馆助手版本 >= '${expected}'`, '版本不兼容');\n  }\n}\n\nexport function prettifyErrorWithInput(error: z.ZodError) {\n  return _([...error.issues])\n    .sortBy(issue => issue.path?.length ?? 0)\n    .flatMap(issue => {\n      const lines = [`✖ ${issue.message}`];\n      if (issue.path?.length) {\n        lines.push(`  → 路径: ${toDotPath(issue.path)}`);\n      }\n      if (issue.input !== undefined) {\n        lines.push(`  → 输入: ${JSON.stringify(issue.input)}`);\n      }\n      return lines;\n    })\n    .join('\\n');\n}\n\nexport function literalYamlify(value: any) {\n  return YAML.stringify(value, { blockQuote: 'literal' });\n}\n\nexport function parseString(content: string): any {\n  let parsed: unknown;\n  try {\n    parsed = YAML.parseDocument(content, { merge: true }).toJS();\n  } catch (yaml_error) {\n    try {\n      // eslint-disable-next-line import-x/no-named-as-default-member\n      parsed = JSON5.parse(content);\n    } catch (json5_error) {\n      try {\n        parsed = JSON.parse(jsonrepair(content));\n      } catch (json_error) {\n        const toError = (error: unknown) => (error instanceof Error ? error.message : String(error));\n        throw new Error(\n          literalYamlify({\n            ['要解析的字符串不是有效的 YAML/JSON 格式']: {\n              字符串内容: content,\n              YAML错误信息: toError(yaml_error),\n              JSON5错误信息: toError(json5_error),\n              尝试修复JSON时的错误信息: toError(json_error),\n            },\n          }),\n        );\n      }\n    }\n  }\n  return parsed;\n}\n\nexport async function checkAndUpdateCharacter(name: string, latest_version: string, png_url: string): Promise<void> {\n  const current_version = (await getCharacter(name)).version.trim() || '0.0.0';\n  if (compare(current_version, latest_version, '>=')) {\n    return;\n  }\n  await importRawCharacter(name, await fetch(png_url).then(response => response.blob()));\n  replaceCharacter(name, { version: latest_version });\n  toastr.success(\n    `角色卡已自动更新到 '${latest_version.startsWith('v') ? latest_version : `v${latest_version}`}'`,\n    name,\n  );\n}\n"],"names":["$","async","name","latest_version","png_url","current_version","getCharacter","version","trim","importRawCharacter","fetch","then","response","blob","replaceCharacter","toastr","success","startsWith","checkAndUpdateCharacter","text","_","get","YAML","parse","catch"],"ignoreList":[],"sourceRoot":""}